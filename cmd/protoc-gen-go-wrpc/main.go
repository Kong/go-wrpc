package main

import (
	"fmt"
	"regexp"
	"runtime/debug"
	"strconv"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
)

const (
	fileSuffix     = "_wrpc.go"
	wrpcImportPath = "github.com/kong/go-wrpc/wrpc"
	generatorName  = "protoc-gen-go-wrpc"
)

func main() {
	opts := protogen.Options{}
	opts.Run(func(plugin *protogen.Plugin) error {
		for _, file := range plugin.Files {
			if !file.Generate {
				continue
			}
			if len(file.Services) == 0 {
				continue
			}
			g := generator{
				file: file,
				gf: plugin.NewGeneratedFile(file.
					GeneratedFilenamePrefix+fileSuffix,
					file.GoImportPath),
			}
			err := g.genFile()
			if err != nil {
				plugin.Error(fmt.Errorf(
					"generate '%v': %v"+
						"", file.GeneratedFilenamePrefix+fileSuffix,
					err))
				return nil
			}
		}
		return nil
	})
}

type generator struct {
	file *protogen.File
	gf   *protogen.GeneratedFile
}

func (g generator) genFile() error {
	g.gf.P(fmt.Sprintf("// Code generated by %s. DO NOT EDIT", generatorName))
	g.gf.P(fmt.Sprintf("// %s version: %s", generatorName, getVersion()))
	g.gf.P()
	g.gf.P("package ", g.file.GoPackageName)
	for _, service := range g.file.Services {
		err := g.genService(service)
		if err != nil {
			return err
		}
	}
	return nil
}

func (g generator) genService(service *protogen.Service) error {
	_, err := serviceID(service)
	if err != nil {
		return err
	}

	err = g.genServiceInterface(service)
	if err != nil {
		return err
	}
	err = g.genPreparer(service)
	if err != nil {
		return err
	}
	err = g.genClient(service)
	if err != nil {
		return err
	}
	err = g.genServer(service)
	if err != nil {
		return err
	}
	return nil
}

func (g generator) genRPC(rpc *protogen.Method) error {
	_, err := rpcID(rpc)
	if err != nil {
		return err
	}

	c := g.gf.QualifiedGoIdent(protogen.GoIdent{
		GoName:       "Context",
		GoImportPath: "context",
	})
	p := g.gf.QualifiedGoIdent(protogen.GoIdent{
		GoName: "Peer", GoImportPath: wrpcImportPath,
	})
	req := g.gf.QualifiedGoIdent(rpc.Input.GoIdent)
	resp := g.gf.QualifiedGoIdent(rpc.Output.GoIdent)

	g.gf.P(fmt.Sprintf("%s(%s, *%s, *%s) (*%s, %s)", rpc.GoName,
		c, p, req, resp, "error",
	))
	return nil
}

func (g generator) genServiceInterface(service *protogen.Service) error {
	g.gf.P("type ", service.GoName, " interface{")
	for _, rpc := range service.Methods {
		err := g.genRPC(rpc)
		if err != nil {
			return err
		}
	}
	g.gf.P("}")

	g.gf.P()
	return nil
}

func (g generator) genPreparer(service *protogen.Service) error {
	for _, rpc := range service.Methods {
		err := g.genPrepareRequest(rpc)
		if err != nil {
			return err
		}
	}
	return nil
}

func (g generator) genPrepareRequest(rpc *protogen.Method) error {
	serviceID, err := serviceID(rpc.Parent)
	if err != nil {
		return err
	}
	rpcID, err := rpcID(rpc)
	if err != nil {
		return err
	}

	req := g.gf.QualifiedGoIdent(rpc.Input.GoIdent)
	retReq := g.gf.QualifiedGoIdent(protogen.GoIdent{
		GoName: "Request", GoImportPath: wrpcImportPath,
	})
	createRequest := g.gf.QualifiedGoIdent(protogen.GoIdent{
		GoName: "CreateRequest", GoImportPath: wrpcImportPath,
	})

	g.gf.P(fmt.Sprintf("func Prepare%s%sRequest(in *%s) (%s, error) {",
		rpc.Parent.GoName, rpc.GoName, req, retReq))
	g.gf.P(fmt.Sprintf("return %s(%v, %v, in)",
		createRequest, serviceID, rpcID))
	g.gf.P("}")
	g.gf.P()
	return nil
}

func (g generator) genClient(service *protogen.Service) error {
	g.gf.P("type ", service.GoName, "Client struct{")
	g.gf.P("Peer *",
		g.gf.QualifiedGoIdent(protogen.
			GoIdent{GoName: "Peer", GoImportPath: wrpcImportPath}))
	g.gf.P("}")
	g.gf.P()
	for _, rpc := range service.Methods {
		err := g.genClientRPC(rpc)
		if err != nil {
			return err
		}
	}
	return nil
}

func (g generator) genClientRPC(rpc *protogen.Method) error {
	serviceID, err := serviceID(rpc.Parent)
	if err != nil {
		return err
	}
	rpcID, err := rpcID(rpc)
	if err != nil {
		return err
	}

	req := g.gf.QualifiedGoIdent(rpc.Input.GoIdent)
	resp := g.gf.QualifiedGoIdent(rpc.Output.GoIdent)

	g.gf.P(fmt.Sprintf("func (c *%s) %s(ctx context.Context, "+
		"in *%s) (*%s, error) {", rpc.Parent.GoName+"Client", rpc.GoName, req,
		resp))

	g.gf.P(fmt.Sprintf("err := c.Peer.VerifyRPC(%v, %v)", serviceID, rpcID))
	g.gf.P("if err != nil {")
	g.gf.P("return nil, err")
	g.gf.P("}")
	g.gf.P()

	g.gf.P(fmt.Sprintf("req, err := Prepare%s%sRequest(in)", rpc.Parent.GoName, rpc.GoName))
	g.gf.P("if err != nil {")
	g.gf.P("return nil, err")
	g.gf.P("}")
	g.gf.P()

	g.gf.P("var out ", resp)

	g.gf.P("err = c.Peer.DoRequest(ctx, req, &out)")

	g.gf.P("if err != nil {")
	g.gf.P("return nil, err")
	g.gf.P("}")
	g.gf.P()
	g.gf.P("return &out, nil")
	g.gf.P("}")
	g.gf.P()
	return nil
}

func (g generator) genServer(service *protogen.Service) error {
	g.gf.P("type ", service.GoName, "Server struct{")
	g.gf.P(service.GoName, " ",
		g.gf.QualifiedGoIdent(protogen.
			GoIdent{GoName: service.GoName, GoImportPath: g.file.GoImportPath}))
	g.gf.P("}")

	err := g.genServerFuncs(service)
	if err != nil {
		return err
	}
	return nil
}

func (g generator) genServerFuncs(service *protogen.Service) error {
	g.gf.P(fmt.Sprintf("func (s *%s) ID() wrpc.ID {",
		service.GoName+"Server"))
	id, err := serviceID(service)
	if err != nil {
		return err
	}
	g.gf.P(fmt.Sprintf("return %v", id))
	g.gf.P("}")
	g.gf.P()

	g.gf.P(fmt.Sprintf("func (s *%s) RPC(rpc wrpc.ID) wrpc.RPC {",
		service.GoName+"Server"))
	g.gf.P("switch rpc {")
	for _, rpc := range service.Methods {
		err := g.genServerRPCCase(rpc)
		if err != nil {
			return err
		}
	}
	g.gf.P("default:")
	g.gf.P("return nil")
	g.gf.P("}")
	g.gf.P("}")
	g.gf.P()
	return nil
}

func (g generator) genServerRPCCase(rpc *protogen.Method) error {
	rpcID, err := rpcID(rpc)
	if err != nil {
		return err
	}
	g.gf.P(fmt.Sprintf("case %v:", rpcID))
	g.gf.P("return wrpc.RPCImpl{")
	g.gf.P("HandlerFunc: func(ctx context.Context, peer *wrpc.Peer, " +
		"decode func(interface{}) error) (interface{}, error) {")

	req := g.gf.QualifiedGoIdent(rpc.Input.GoIdent)

	g.gf.P("var in ", req)
	g.gf.P("err := decode(&in)")
	g.gf.P("if err != nil {")
	g.gf.P("return nil,err")
	g.gf.P("}")
	g.gf.P(fmt.Sprintf("return s.%s.%s(ctx, peer, &in)", rpc.Parent.GoName,
		rpc.GoName))

	g.gf.P("},")
	g.gf.P("}")

	return nil
}

var (
	svcRegex = regexp.MustCompile(`^\/\/\s\+wrpc:service-id=(-?\d+)$`)
	rpcRegex = regexp.MustCompile(`^\/\/\s\+wrpc:rpc-id=(-?\d+)$`)
)

func serviceID(service *protogen.Service) (uint32, error) {
	id, err := findID(service.Comments.Leading, svcRegex)
	if err != nil {
		return 0, fmt.Errorf("wRPC ID for service '%v': %w",
			service.GoName, err)
	}
	return id, nil
}

func rpcID(rpc *protogen.Method) (uint32, error) {
	id, err := findID(rpc.Comments.Leading, rpcRegex)
	if err != nil {
		return 0, fmt.Errorf("wRPC ID for rpc '%v': %w",
			rpc.GoName, err)
	}
	return id, nil
}

func findID(comments protogen.Comments, r *regexp.Regexp) (uint32, error) {
	lines := strings.Split(comments.String(), "\n")
	for _, line := range lines {
		svcRegex.MatchString(line)
		matches := r.FindStringSubmatch(line)
		const expectedMatches = 2
		if len(matches) == expectedMatches {
			id, err := strconv.Atoi(matches[1])
			if err != nil {
				return 0, err
			}
			if id <= 0 {
				return 0, fmt.Errorf("invalid id: %v", id)
			}
			return uint32(id), nil
		}
	}
	return 0, fmt.Errorf("not found")
}

func getVersion() string {
	v := "devel"

	info, ok := debug.ReadBuildInfo()
	if ok {
		v = info.Main.Version
	}
	return v
}
